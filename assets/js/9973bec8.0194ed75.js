"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[693],{8030:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var o=t(4848),s=t(8453);const i={sidebar_position:4},r="Ultron Compose API",a={id:"compose/api",title:"Ultron Compose API",description:"The framework provides an extended API for Compose UI testing. Basically, it's available for SemanticsMatcher object. It could be created by functions like hasTestTag(),  hasText() and etc.",source:"@site/docs/compose/api.md",sourceDirName:"compose",slug:"/compose/api",permalink:"/ultron/docs/compose/api",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Android",permalink:"/ultron/docs/compose/android"},next:{title:"LazyList",permalink:"/ultron/docs/compose/lazylist"}},l={},c=[{value:"<em>Best practice</em>",id:"best-practice",level:3},{value:"Extend framework with your own compose operations",id:"extend-framework-with-your-own-compose-operations",level:2}];function p(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"ultron-compose-api",children:"Ultron Compose API"}),"\n",(0,o.jsxs)(n.p,{children:["The framework provides an extended API for Compose UI testing. Basically, it's available for ",(0,o.jsx)(n.code,{children:"SemanticsMatcher"})," object. It could be created by functions like ",(0,o.jsx)(n.code,{children:"hasTestTag()"}),",  ",(0,o.jsx)(n.code,{children:"hasText()"})," and etc."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'//config\nfun withTimeout(timeoutMs: Long)  // to change an operation timeout from default one\nfun withResultHandler(resultHandler: (ComposeOperationResult<UltronComposeOperation>) -> Unit) // provide a scope to modify operation result processing\nfun <T> isSuccess(action: UltronComposeSemanticsNodeInteraction.() -> T): Boolean\nfun withAssertion(assertion: OperationAssertion)\nfun withAssertion(name: String = "", isListened: Boolean = false, block: () -> Unit)\nfun withUseUnmergedTree(value: Boolean) \nfun withName(name: String) // specify custom name for UI element, it\'ll be visible in log, exception, and step name for detailed allure report\nfun withDescription(description: String) // analog of fun withName(name: String) for matchers of UltronComposeList, UltronComposeListItem, and child of UltronComposeListItem\nfun withMetaInfo(meta: Any) // allows association of custom info with UI element\n\n//actions\nfun click(option: ClickOption? = null)\nfun clickCenterLeft(option: ClickOption? = null)\nfun clickCenterRight(option: ClickOption? = null)\nfun clickTopCenter(option: ClickOption? = null)\nfun clickTopLeft(option: ClickOption? = null)\nfun clickTopRight(option: ClickOption? = null)\nfun clickBottomCenter(option: ClickOption? = null)\nfun clickBottomLeft(option: ClickOption? = null)\nfun clickBottomRight(option: ClickOption? = null)\nfun longClick(option: LongClickOption? = null)\nfun longClickCenterLeft(option: LongClickOption? = null)\nfun longClickCenterRight(option: LongClickOption? = null)\nfun longClickTopCenter(option: LongClickOption? = null)\nfun longClickTopLeft(option: LongClickOption? = null)\nfun longClickTopRight(option: LongClickOption? = null)\nfun longClickBottomCenter(option: LongClickOption? = null)\nfun longClickBottomLeft(option: LongClickOption? = null)\nfun longClickBottomRight(option: LongClickOption? = null)\nfun doubleClick(option: DoubleClickOption? = null)\nfun doubleClickCenterLeft(option: DoubleClickOption? = null)\nfun doubleClickCenterRight(option: DoubleClickOption? = null)\nfun doubleClickTopCenter(option: DoubleClickOption? = null)\nfun doubleClickTopLeft(option: DoubleClickOption? = null)\nfun doubleClickTopRight(option: DoubleClickOption? = null)\nfun doubleClickBottomCenter(option: DoubleClickOption? = null)\nfun doubleClickBottomLeft(option: DoubleClickOption? = null)\nfun doubleClickBottomRight(option: DoubleClickOption? = null)\nfun swipeDown(option: ComposeSwipeOption? = null)\nfun swipeUp(option: ComposeSwipeOption? = null)\nfun swipeLeft(option: ComposeSwipeOption? = null)\nfun swipeRight(option: ComposeSwipeOption? = null)\nfun scrollTo()\nfun scrollToIndex(index: Int)\nfun scrollToKey(key: String)\nfun scrollToNode(matcher: SemanticsMatcher)\nfun imeAction()\nfun pressKey(keyEvent: KeyEvent)\nfun getText(): String?\nfun inputText(text: String)\nfun typeText(text: String)\nfun inputTextSelection(selection: TextRange)\nfun setSelection(startIndex: Int = 0, endIndex: Int = 0, traversalMode: Boolean)\nfun selectText(range: TextRange)\nfun clearText()\nfun replaceText(text: String)\nfun copyText()\nfun pasteText()\nfun cutText()\nfun setText(text: String)\nfun setText(text: AnnotatedString)\nfun collapse()\nfun expand()\nfun dismiss()\nfun setProgress(value: Float)\nfun captureToImage(): ImageBitmap\n\nfun performMouseInput(block: MouseInjectionScope.() -> Unit)\nfun performSemanticsAction(key: SemanticsPropertyKey<AccessibilityAction<() -> Boolean>>) \nfun perform(params: UltronComposeOperationParams? = null, block: (SemanticsNodeInteraction) -> Unit)\nfun <T> execute(params: UltronComposeOperationParams? = null, block: (SemanticsNodeInteraction) -> T): T\n\nfun getNode(): SemanticsNode\nfun <T> getNodeConfigProperty(key: SemanticsPropertyKey<T>): T\n\n//asserts\nfun assertIsDisplayed()\nfun assertIsNotDisplayed() \nfun assertExists()\nfun assertDoesNotExist()\nfun assertIsEnabled() \nfun assertIsNotEnabled() \nfun assertIsFocused() \nfun assertIsNotFocused() \nfun assertIsSelected() \nfun assertIsNotSelected()\nfun assertIsSelectable()\nfun assertIsOn() \nfun assertIsOff() \nfun assertIsToggleable() \nfun assertHasClickAction() \nfun assertHasNoClickAction() \nfun assertTextEquals(vararg expected: String, option: TextEqualsOption? = null)\nfun assertTextContains(expected: String, option: TextContainsOption? = null)\nfun assertContentDescriptionEquals(vararg expected: String)\nfun assertContentDescriptionContains(expected: String, option: ContentDescriptionContainsOption? = null)\nfun assertValueEquals(expected: String) \nfun assertRangeInfoEquals(range: ProgressBarRangeInfo)\nfun assertHeightIsAtLeast(minHeight: Dp) \nfun assertHeightIsEqualTo(expectedHeight: Dp)\nfun assertWidthIsAtLeast(minWidth: Dp) \nfun assertWidthIsEqualTo(expectedWidth: Dp) \nfun assertMatches(matcher: SemanticsMatcher, messagePrefixOnError: (() -> String)? = null) \n'})}),"\n",(0,o.jsx)(n.h3,{id:"best-practice",children:(0,o.jsx)(n.em,{children:"Best practice"})}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.p,{children:"Use Page Object pattern. Specify page elements as properties of Page class"}),"\n"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"object SomePage : Page<SomePage>() {\n    private val button = hasTestTag(ComposeTestTags.button)\n    private val eventStatus = hasTestTag(ComposeTestTags.eventStatus)\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here ",(0,o.jsx)(n.code,{children:"ComposeTestTags"})," could be an object that stores testTag constants."]}),"\n",(0,o.jsx)(n.p,{children:"Use this properties in page steps"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"object SomePage : Page<SomePage>() {\n    //page elements\n    fun someUserStepOnPage(expectedEventText: String) = apply {\n         button.click()\n         eventStatus.assertTextContains(expectedEventText)\n    }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It's possible to use term ",(0,o.jsx)(n.code,{children:"Screen"})," instead of ",(0,o.jsx)(n.code,{children:"Page"}),". They are equals."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"object SomeScreen : Screen<SomeScreen>() { ... }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"extend-framework-with-your-own-compose-operations",children:"Extend framework with your own compose operations"}),"\n",(0,o.jsxs)(n.p,{children:["Under the hood all Ultron compose operations are described in ",(0,o.jsx)(n.code,{children:"UltronComposeSemanticsNodeInteraction"})," class. That is why you just need to extend this class using ",(0,o.jsx)(n.a,{href:"https://kotlinlang.org/docs/extensions.html",children:"kotlin extension function"}),", e.g."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"//new semantic matcher for assertion\nfun hasProgress(value: Float): SemanticsMatcher = SemanticsMatcher.expectValue(GetProgress, value)\n\n//add new operation\nfun UltronComposeSemanticsNodeInteraction.assertProgress(expected: Float) = apply {\n    executeOperation(\n        operationBlock = { semanticsNodeInteraction.assert(hasProgress(expected)) },\n        name = \"Assert '${semanticsNodeInteraction.getDescription()}' has progress $expected\",\n        description = \"Compose assertProgress = $expected in '${semanticsNodeInteraction.getDescription()}' during $timeoutMs ms\",\n    )\n}\n\n//extend SemanticsMatcher with your new operation\nfun SemanticsMatcher.assertProgress(expected: Float) = UltronComposeSemanticsNodeInteraction(this).assertProgress(expected)\n"})}),"\n",(0,o.jsx)(n.p,{children:"How to use"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:"val progress = 0.7f\nhasTestTag(ComposeElementsActivity.progressBar).setProgress(progress).assertProgress(progress)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You may ask what is ",(0,o.jsx)(n.code,{children:"GetProgress"}),"?"]}),"\n",(0,o.jsx)(n.p,{children:"This is a feature of Compose framework. It's available to extend you app with custom SemanticsPropertyKey. Define it in app and assert it in tests."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-kotlin",children:'//application code\n@Composable\nfun LinearProgressBar(statusState: MutableState<String>){\n    val progressState = remember {\n        mutableStateOf(0f)\n    }\n    LinearProgressIndicator(progress = progressState.value, modifier =\n    Modifier\n        .semantics {\n            testTag = ComposeElementsActivity.progressBar\n            setProgress { value ->\n                progressState.value = value\n                statusState.value = "set progress $value"\n                true\n            }\n            progressBarRangeInfo = ProgressBarRangeInfo(progressState.value, 0f..progressState.value, 100)\n        }\n        .getProgress(progressState.value)\n        .progressSemantics()\n    )\n}\n\nval GetProgress = SemanticsPropertyKey<Float>("ProgressValue")\nvar SemanticsPropertyReceiver.getProgress by GetProgress\n\nfun Modifier.getProgress(progress: Float): Modifier {\n    return semantics { getProgress = progress }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);