"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[460],{6974:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>c,toc:()=>r});var n=s(4848),i=s(8453);const o={sidebar_position:5},a="LazyList",c={id:"compose/lazylist",title:"LazyList",description:"Ultron LazyColumn/LazyRow",source:"@site/docs/compose/lazylist.md",sourceDirName:"compose",slug:"/compose/lazylist",permalink:"/ultron/docs/compose/lazylist",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Ultron Compose API",permalink:"/ultron/docs/compose/api"},next:{title:"Espresso",permalink:"/ultron/docs/android/espress"}},l={},r=[{value:"Ultron LazyColumn/LazyRow",id:"ultron-lazycolumnlazyrow",level:2},{value:"UltronComposeList",id:"ultroncomposelist",level:2},{value:"<em>Best practice</em> - define <code>UltronComposeList</code> object as page class property",id:"best-practice---define-ultroncomposelist-object-as-page-class-property",level:3},{value:"<code>UltronComposeList</code> API",id:"ultroncomposelist-api",level:3},{value:"useUnmergedTree",id:"useunmergedtree",level:3},{value:"UltronComposeListItem",id:"ultroncomposelistitem",level:2},{value:"Simple <code>UltronComposeListItem</code>",id:"simple-ultroncomposelistitem",level:3},{value:"Complex <code>UltronComposeListItem</code> with children",id:"complex-ultroncomposelistitem-with-children",level:3},{value:"<em>Best practice</em>",id:"best-practice",level:3},{value:"<code>UltronComposeListItem</code> API",id:"ultroncomposelistitem-api",level:2},{value:"Efficient Strategies for Locating Items in Compose LazyList",id:"efficient-strategies-for-locating-items-in-compose-lazylist",level:2},{value:"1. <code>..visibleItem</code>",id:"1-visibleitem",level:3},{value:"2. Item by unique <code>SemanticsMatcher</code>",id:"2-item-by-unique-semanticsmatcher",level:3},{value:"3. Set up <code>positionPropertyKey</code>",id:"3-set-up-positionpropertykey",level:3},{value:"4. Set up item <code>testTag</code>",id:"4-set-up-item-testtag",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",hr:"hr",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"lazylist",children:"LazyList"}),"\n",(0,n.jsx)(t.h2,{id:"ultron-lazycolumnlazyrow",children:"Ultron LazyColumn/LazyRow"}),"\n",(0,n.jsxs)(t.p,{children:["It's pretty much familiar with ",(0,n.jsx)(t.code,{children:"UltronRecyclerView"})," approach. The difference is in internal structure of ",(0,n.jsx)(t.code,{children:"RecyclerView "}),"and ",(0,n.jsx)(t.code,{children:"LazyColumn/LazyRow"}),".\nDue to implementation features of LazyColumn/LazyRow we can't predict where matched item is located in list without scrolling (actually we can but it takes additional efforts from development)"]}),"\n",(0,n.jsx)(t.p,{children:"Before we go forward we need to clarify some terms:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["ComposeList - list of some items. It's typically implemented in application as LazyColumnt or LazyRow. Ultron has a class that wraps an interaction with list - ",(0,n.jsx)(t.code,{children:"UltronComposeList"}),"."]}),"\n",(0,n.jsxs)(t.li,{children:["ComposeListItem - single item of ComposeList (there is a class ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:["ComposeListItemChild - child element of ComposeListItem (just a term, there is no special class to work with child elements). So ",(0,n.jsx)(t.em,{children:"ComposeListItemChild"})," could be considered as a simple compose node."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{src:"https://user-images.githubusercontent.com/12834123/188237127-32e501ca-ae8b-4cd4-8114-e3e17843dc55.PNG",alt:"lazyColumn"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"ultroncomposelist",children:"UltronComposeList"}),"\n",(0,n.jsxs)(t.p,{children:["Create an instance of ",(0,n.jsx)(t.code,{children:"UltronComposeList"})," by calling a method ",(0,n.jsx)(t.code,{children:"composeList(..)"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"composeList(hasTestTag(contactsListTestTag)).assertNotEmpty()\n"})}),"\n",(0,n.jsxs)(t.h3,{id:"best-practice---define-ultroncomposelist-object-as-page-class-property",children:[(0,n.jsx)(t.em,{children:"Best practice"})," - define ",(0,n.jsx)(t.code,{children:"UltronComposeList"})," object as page class property"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"object ContactsListPage : Page<ContactsListPage >() {\n   val lazyList = composeList(hasContentDescription(contactsListContentDesc))\n    fun someStep(){\n        lazyList.assertNotEmpty() \n        lazyList.assertContentDescriptionEquals(contactsListContentDesc)\n    }\n}\n"})}),"\n",(0,n.jsxs)(t.h3,{id:"ultroncomposelist-api",children:[(0,n.jsx)(t.code,{children:"UltronComposeList"})," API"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"withTimeout(timeoutMs: Long) // defines a timeout for all operations \n//assertions\nfun assertIsDisplayed() \nfun assertIsNotDisplayed()\nfun assertExists() \nfun assertDoesNotExist()\nfun assertContentDescriptionEquals(vararg expected: String)\nfun assertContentDescriptionContains(expected: String, option: ContentDescriptionContainsOption? = null)\nfun assertNotEmpty()\nfun assertEmpty()\nfun assertVisibleItemsCount(expected: Int) \n\n//item providers for simple UltronComposeListItem\nfun item(matcher: SemanticsMatcher): UltronComposeListItem\nfun visibleItem(index: Int): UltronComposeListItem\nfun firstVisibleItem(): UltronComposeListItem\nfun lastVisibleItem(): UltronComposeListItem\n\n// ----- item providers for UltronComposeListItem subclasses -----\n// following methods return a generic type T which is a subclass of UltronComposeListItem\nfun getItem(matcher: SemanticsMatcher): T\nfun getVisibleItem(index: Int): T\nfun getFirstVisibleItem(): T \nfun getLastVisibleItem(): T\n\n//interaction provider\nvisibleChild(matcher: SemanticsMatcher)  // provides an interaction on visible matched item\n\n//actions\nfun getVisibleItemsCount(): Int\nfun scrollToNode(itemMatcher: SemanticsMatcher)\nfun scrollToIndex(index: Int) \nfun scrollToKey(key: Any)\n/**\n* Provide a scope with references to list SemanticsNode and SemanticsNodeInteraction.\n* It is possible to evaluate any action or assertion on this node.\n*/\nfun <T> performOnList(block: (SemanticsNode, SemanticsNodeInteraction) -> T): T\n"})}),"\n",(0,n.jsx)(t.h3,{id:"useunmergedtree",children:"useUnmergedTree"}),"\n",(0,n.jsxs)(t.p,{children:["It is really important to understand the difference btwn merged and unmerged tree. There is a property ",(0,n.jsx)(t.code,{children:"useUnmergedTree"})," that defines a behaviour."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"composeList(hasTestTag(contactsListTestTag), useUnmergedTree = false)\n"})}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["By default ",(0,n.jsx)(t.code,{children:"UltronComposeList"})," uses unmerged tree (",(0,n.jsx)(t.code,{children:"useUnmergedTree = true"}),"). All child elements contain info in seperate nodes."]}),"\n",(0,n.jsxs)(t.li,{children:["In case we use merged tree (",(0,n.jsx)(t.code,{children:"useUnmergedTree = false"}),") all child elements of item is merged to single node. So you're not able to identify a text value of concrete child."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Why it's important? Cause you need to use different SemanticsMatchers to find appropriate child."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"mergedTreeList.item(hasText(contact.name)) // contact.name could be placed in wrong child\nunmergedList.item(hasAnyDescendant(hasText(contact.name) and hasTestTag(contactNameTestTag))) //it's longer but certainly provides target node\n"})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"ultroncomposelistitem",children:"UltronComposeListItem"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:"UltronComposeList"})," provides an access to ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"})]}),"\n",(0,n.jsxs)(t.p,{children:["There is a set of methods to create ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"}),". It's listed upper in ",(0,n.jsx)(t.code,{children:"UltronComposeList"})," api."]}),"\n",(0,n.jsxs)(t.h3,{id:"simple-ultroncomposelistitem",children:["Simple ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"})]}),"\n",(0,n.jsxs)(t.p,{children:["If you don't need to interact with item child just use methods like  ",(0,n.jsx)(t.code,{children:"item"}),", ",(0,n.jsx)(t.code,{children:"firstItem"}),", ",(0,n.jsx)(t.code,{children:"visibleItem"}),", ",(0,n.jsx)(t.code,{children:"firstVisibleItem"}),", ",(0,n.jsx)(t.code,{children:"lastVisibleItem"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"listWithMergedTree.item(hasText(contact.name)).assertTextContains(contact.name)\nlistWithMergedTree.firstVisibleItem()\n    .assertIsDisplayed()\n    .assertTextContains(contact.name)\n    .assertTextContains(contact.status)\n"})}),"\n",(0,n.jsx)(t.p,{children:"You don't need to worry about scroll to item. It's executed automatically."}),"\n",(0,n.jsxs)(t.h3,{id:"complex-ultroncomposelistitem-with-children",children:["Complex ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"})," with children"]}),"\n",(0,n.jsx)(t.p,{children:"It's often required to interact with item child. The best solution will be to describe children as properties of UltronComposeListItem subclass."}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"class ComposeFriendListItem : UltronComposeListItem(){\n    val name by child { hasTestTag(contactNameTestTag) }\n    val status by child { hasTestTag(contactStatusTestTag) }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsxs)(t.strong,{children:["Note: you have to use delegated initialisation with ",(0,n.jsx)(t.code,{children:"by child"}),"."]})}),"\n",(0,n.jsxs)(t.p,{children:["For Compose Multiplatform project you need to register Item class instances with ",(0,n.jsx)(t.code,{children:"initBlock"})," param:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"composeList(.., initBlock = {\n    registerItem { ComposeFriendListItem() }\n    registerItem { AnotherListItem() }\n})\n"})}),"\n",(0,n.jsx)(t.p,{children:"It is required cause Kotlin Multiplatfor Project has limited reflation API for different platforms."}),"\n",(0,n.jsx)(t.p,{children:"You don't need to register Items for Android UI tests."}),"\n",(0,n.jsxs)(t.p,{children:["Now you're able to get ",(0,n.jsx)(t.code,{children:"ComposeFriendListItem"})," object using methods ",(0,n.jsx)(t.code,{children:"getItem"}),", ",(0,n.jsx)(t.code,{children:"getVisibleItem"}),", ",(0,n.jsx)(t.code,{children:"getFirstVisibleItem"}),", ",(0,n.jsx)(t.code,{children:"getLastVisibleItem"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"lazyList.getFirstVisibleItem<ComposeFriendListItem>()\nlazyList.getVisibleItem<ComposeFriendListItem>(index)\nlazyList.getItem<ComposeFriendListItem>(hasTestTag(..))\n"})}),"\n",(0,n.jsx)(t.h3,{id:"best-practice",children:(0,n.jsx)(t.em,{children:"Best practice"})}),"\n",(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsxs)(t.p,{children:["Add a method to ",(0,n.jsx)(t.code,{children:"Page"})," class that returns ",(0,n.jsx)(t.code,{children:"UltronComposeListItem"})," subclass"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Mark such methods with ",(0,n.jsx)(t.code,{children:"private"})," visibility modifier. e.g. ",(0,n.jsx)(t.code,{children:"getContactItem"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"object ComposeListPage : Page<ComposeListPage>() {\n    private val lazyList = composeList(hasContentDescription(contactsListContentDesc), ..)\n    private fun getContactItem(contact: Contact): ComposeFriendListItem = lazyList.getItem(hasTestTag(contact.id))\n\n    class ComposeFriendListItem : UltronComposeListItem(){\n        val name by lazy { getChild(hasTestTag(contactNameTestTag)) }\n        val status by lazy { getChild(hasTestTag(contactStatusTestTag)) }\n    }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Use ",(0,n.jsx)(t.code,{children:"getContactItem"})," in ",(0,n.jsx)(t.code,{children:"Page"})," steps like ",(0,n.jsx)(t.code,{children:"assertContactStatus"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"object ComposeListPage : Page<ComposeListPage>() {\n    private fun getContactItem(contact: Contact): ComposeFriendListItem = lazyList.getItem(hasTestTag(contact.id))\n    ...\n    fun assertContactStatus(contact: Contact) = apply {\n         getContactItem(contact).status.assertTextEquals(contact.status)\n    }\n}\n"})}),"\n",(0,n.jsxs)(t.h2,{id:"ultroncomposelistitem-api",children:[(0,n.jsx)(t.code,{children:"UltronComposeListItem"})," API"]}),"\n",(0,n.jsxs)(t.p,{children:["It's pretty much the same as ",(0,n.jsx)(t.a,{href:"/ultron/docs/compose/api",children:"simple node api"}),", but extends it mostly for internal features."]}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.h2,{id:"efficient-strategies-for-locating-items-in-compose-lazylist",children:"Efficient Strategies for Locating Items in Compose LazyList"}),"\n",(0,n.jsxs)(t.p,{children:["Let's start with approaches that you can use without additional efforts. For example, you have identified ",(0,n.jsx)(t.code,{children:"LazyList"})," in your tests code like"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'val lazyList = composeList(listMatcher = hasTestTag("listTestTag").withDescription(description = "List of contacts"), ..)\n\nclass ComposeListItem : UltronComposeListItem() {\n    val name by lazy { getChild(hasTestTag(contactNameTestTag).withDescription(description = "Contact name")) }\n    val status by lazy { getChild(hasTestTag(contactStatusTestTag).withDescription(description = "Contact status")) }\n}\n'})}),"\n",(0,n.jsxs)(t.h3,{id:"1-visibleitem",children:["1. ",(0,n.jsx)(t.code,{children:"..visibleItem"})]}),"\n",(0,n.jsxs)(t.p,{children:["This is probably the most unstable approach. It's only suitable in case you didn't interact with ",(0,n.jsx)(t.code,{children:"LazyList"})," and would like to reach an item that is on the screen."]}),"\n",(0,n.jsx)(t.p,{children:"Use the following methods:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"lazyList.firstVisibleItem()\nlazyList.visibleItem(index = 3)\nlazyList.lastVisibleItem()\n\nlazyList.getFirstVisibleItem<ComposeListItem>()\nlazyList.getVisibleItem<ComposeListItem>(index = 3)\nlazyList.getLastVisibleItem<ComposeListItem>()\n"})}),"\n",(0,n.jsxs)(t.h3,{id:"2-item-by-unique-semanticsmatcher",children:["2. Item by unique ",(0,n.jsx)(t.code,{children:"SemanticsMatcher"})]}),"\n",(0,n.jsxs)(t.p,{children:["A more stable way to find the item is to use ",(0,n.jsx)(t.code,{children:"SemanticsMatcher"}),". It allows you to find the item not only on the screen."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'val someText = "Some unique text"\nlazyList.item(hasAnyDescendant(hasText(someText).withDescription(description = someText)) \nlazyList.getItem<ComposeListItem>(hasAnyDescendant(hasText("Some unique text")) \n'})}),"\n",(0,n.jsx)(t.hr,{}),"\n",(0,n.jsx)(t.p,{children:"The next two approaches require additional code in the application. These are the most stable and preferable ways."}),"\n",(0,n.jsxs)(t.h3,{id:"3-set-up-positionpropertykey",children:["3. Set up ",(0,n.jsx)(t.code,{children:"positionPropertyKey"})]}),"\n",(0,n.jsx)(t.p,{children:"By default, a compose list item doesn't have a property that stores its position in the list. We can add this property in a really simple way."}),"\n",(0,n.jsx)(t.p,{children:"Here is the application code:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'// create custom SemanticsPropertyKey\nval ListItemPositionPropertyKey = SemanticsPropertyKey<Int>("ListItemPosition")\nvar SemanticsPropertyReceiver.listItemPosition by ListItemPositionPropertyKey\n\n// specify it for item and store item index in this property\n@Composable\nfun ContactsListWithPosition(contacts: List<Contact>\n) {\n    LazyColumn(\n        modifier = Modifier.semantics { testTag = "listTestTag" }\n    ) {\n        itemsIndexed(contacts) { index, contact ->\n            Column(\n                modifier = Modifier.semantics {\n                    listItemPosition = index\n                }\n            ) {\n                // item content\n            }\n        }\n    }\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["After that, you need to specify the custom ",(0,n.jsx)(t.code,{children:"SemanticsPropertyKey"})," in the test code:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'val lazyList = composeList(\n    listMatcher = hasTestTag("listTestTag"),\n    positionPropertyKey = ListItemPositionPropertyKey\n)\n'})}),"\n",(0,n.jsx)(t.p,{children:"It allows you to reach the item by its position in the list:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"lazyList.firstItem()\nlazyList.item(position = 25)\nlazyList.getFirstItem<ComposeListItem>()\nlazyList.getItem<ComposeListItem>(position = 7)\n"})}),"\n",(0,n.jsxs)(t.h3,{id:"4-set-up-item-testtag",children:["4. Set up item ",(0,n.jsx)(t.code,{children:"testTag"})]}),"\n",(0,n.jsxs)(t.p,{children:["It is recommended to build ",(0,n.jsx)(t.code,{children:"testTag"})," in a separate function based on data object."]}),"\n",(0,n.jsxs)(t.p,{children:["For example, let's assume we have a ",(0,n.jsx)(t.code,{children:"Contact"})," data class that stores data to be presented in the item."]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:"data class Contact(val id: Int, val name: String, val status: String, val avatar: String)\n"})}),"\n",(0,n.jsxs)(t.p,{children:["We can create function to build ",(0,n.jsx)(t.code,{children:"testTag"})," based on ",(0,n.jsx)(t.code,{children:"contact.id"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'fun getContactItemTestTag(contact: Contact) = "contactId=${contact.id}"\n'})}),"\n",(0,n.jsxs)(t.p,{children:["We can use this function in the application code to specify ",(0,n.jsx)(t.code,{children:"testTag"})," and in the test code to find the item by ",(0,n.jsx)(t.code,{children:"testTag"}),":"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-kotlin",children:'// application code\n@Composable\nfun ContactsListWithPosition(contacts: List<Contact>\n) {\n    LazyColumn(\n        modifier = Modifier.semantics { testTag = "listTestTag" }\n    ) {\n        itemsIndexed(contacts) { index, contact ->\n            Column(\n                modifier = Modifier.semantics {\n                    listItemPosition = index\n                    testTag = getContactItemTestTag(contact)\n                }\n            ) {\n                // item content\n            }\n        }\n    }\n}\n\n//test code\nval lazyList = composeList(listMatcher = hasTestTag("listTestTag"))\n\nlazyList.item(hasTestTag(getContactItemTestTag(contact)))\nlazyList.getItem<ComposeListItem>(hasTestTag(getContactItemTestTag(contact)))\n\n'})})]})}function m(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>c});var n=s(6540);const i={},o=n.createContext(i);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);